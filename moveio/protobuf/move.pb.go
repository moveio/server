// Code generated by protoc-gen-go.
// source: protobuf/move.proto
// DO NOT EDIT!

/*
Package move is a generated protocol buffer package.

It is generated from these files:
	protobuf/move.proto

It has these top-level messages:
	Pipeline
	Gesture
	Gestures
	Pipelines
	Hooks
	GestureMessage
	Hook
	Token
*/
package move

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Pipeline struct {
	Id          string      `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	UserId      string      `protobuf:"bytes,2,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	Description string      `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	Next        []*Pipeline `protobuf:"bytes,4,rep,name=next" json:"next,omitempty"`
	GestureId   string      `protobuf:"bytes,5,opt,name=gesture_id,json=gestureId" json:"gesture_id,omitempty"`
	Timeout     int64       `protobuf:"varint,6,opt,name=timeout" json:"timeout,omitempty"`
	Name        string      `protobuf:"bytes,7,opt,name=name" json:"name,omitempty"`
	HookId      string      `protobuf:"bytes,8,opt,name=hook_id,json=hookId" json:"hook_id,omitempty"`
}

func (m *Pipeline) Reset()                    { *m = Pipeline{} }
func (m *Pipeline) String() string            { return proto.CompactTextString(m) }
func (*Pipeline) ProtoMessage()               {}
func (*Pipeline) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Pipeline) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Pipeline) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *Pipeline) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Pipeline) GetNext() []*Pipeline {
	if m != nil {
		return m.Next
	}
	return nil
}

func (m *Pipeline) GetGestureId() string {
	if m != nil {
		return m.GestureId
	}
	return ""
}

func (m *Pipeline) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *Pipeline) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Pipeline) GetHookId() string {
	if m != nil {
		return m.HookId
	}
	return ""
}

type Gesture struct {
	Id          string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	Meta        string `protobuf:"bytes,3,opt,name=meta" json:"meta,omitempty"`
	Name        string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	UserId      string `protobuf:"bytes,5,opt,name=user_id,json=userId" json:"user_id,omitempty"`
}

func (m *Gesture) Reset()                    { *m = Gesture{} }
func (m *Gesture) String() string            { return proto.CompactTextString(m) }
func (*Gesture) ProtoMessage()               {}
func (*Gesture) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Gesture) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Gesture) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Gesture) GetMeta() string {
	if m != nil {
		return m.Meta
	}
	return ""
}

func (m *Gesture) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Gesture) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

type Gestures struct {
	Gestures []*Gesture `protobuf:"bytes,1,rep,name=gestures" json:"gestures,omitempty"`
}

func (m *Gestures) Reset()                    { *m = Gestures{} }
func (m *Gestures) String() string            { return proto.CompactTextString(m) }
func (*Gestures) ProtoMessage()               {}
func (*Gestures) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Gestures) GetGestures() []*Gesture {
	if m != nil {
		return m.Gestures
	}
	return nil
}

type Pipelines struct {
	Pipelines []*Pipeline `protobuf:"bytes,1,rep,name=pipelines" json:"pipelines,omitempty"`
}

func (m *Pipelines) Reset()                    { *m = Pipelines{} }
func (m *Pipelines) String() string            { return proto.CompactTextString(m) }
func (*Pipelines) ProtoMessage()               {}
func (*Pipelines) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Pipelines) GetPipelines() []*Pipeline {
	if m != nil {
		return m.Pipelines
	}
	return nil
}

type Hooks struct {
	Hooks []*Hook `protobuf:"bytes,1,rep,name=hooks" json:"hooks,omitempty"`
}

func (m *Hooks) Reset()                    { *m = Hooks{} }
func (m *Hooks) String() string            { return proto.CompactTextString(m) }
func (*Hooks) ProtoMessage()               {}
func (*Hooks) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Hooks) GetHooks() []*Hook {
	if m != nil {
		return m.Hooks
	}
	return nil
}

type GestureMessage struct {
	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	Meta   string `protobuf:"bytes,2,opt,name=meta" json:"meta,omitempty"`
}

func (m *GestureMessage) Reset()                    { *m = GestureMessage{} }
func (m *GestureMessage) String() string            { return proto.CompactTextString(m) }
func (*GestureMessage) ProtoMessage()               {}
func (*GestureMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GestureMessage) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *GestureMessage) GetMeta() string {
	if m != nil {
		return m.Meta
	}
	return ""
}

type Hook struct {
	Id          string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Message     string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	Name        string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	Description string `protobuf:"bytes,4,opt,name=description" json:"description,omitempty"`
	Address     string `protobuf:"bytes,5,opt,name=address" json:"address,omitempty"`
	UserId      string `protobuf:"bytes,6,opt,name=user_id,json=userId" json:"user_id,omitempty"`
}

func (m *Hook) Reset()                    { *m = Hook{} }
func (m *Hook) String() string            { return proto.CompactTextString(m) }
func (*Hook) ProtoMessage()               {}
func (*Hook) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Hook) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Hook) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Hook) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Hook) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Hook) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Hook) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

type Token struct {
	Token string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
}

func (m *Token) Reset()                    { *m = Token{} }
func (m *Token) String() string            { return proto.CompactTextString(m) }
func (*Token) ProtoMessage()               {}
func (*Token) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Token) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func init() {
	proto.RegisterType((*Pipeline)(nil), "Pipeline")
	proto.RegisterType((*Gesture)(nil), "Gesture")
	proto.RegisterType((*Gestures)(nil), "Gestures")
	proto.RegisterType((*Pipelines)(nil), "Pipelines")
	proto.RegisterType((*Hooks)(nil), "Hooks")
	proto.RegisterType((*GestureMessage)(nil), "GestureMessage")
	proto.RegisterType((*Hook)(nil), "Hook")
	proto.RegisterType((*Token)(nil), "Token")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Auths service

type AuthsClient interface {
	Auth(ctx context.Context, in *Token, opts ...grpc.CallOption) (*Token, error)
}

type authsClient struct {
	cc *grpc.ClientConn
}

func NewAuthsClient(cc *grpc.ClientConn) AuthsClient {
	return &authsClient{cc}
}

func (c *authsClient) Auth(ctx context.Context, in *Token, opts ...grpc.CallOption) (*Token, error) {
	out := new(Token)
	err := grpc.Invoke(ctx, "/Auths/Auth", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Auths service

type AuthsServer interface {
	Auth(context.Context, *Token) (*Token, error)
}

func RegisterAuthsServer(s *grpc.Server, srv AuthsServer) {
	s.RegisterService(&_Auths_serviceDesc, srv)
}

func _Auths_Auth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Token)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthsServer).Auth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Auths/Auth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthsServer).Auth(ctx, req.(*Token))
	}
	return interceptor(ctx, in, info, handler)
}

var _Auths_serviceDesc = grpc.ServiceDesc{
	ServiceName: "Auths",
	HandlerType: (*AuthsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Auth",
			Handler:    _Auths_Auth_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protobuf/move.proto",
}

// Client API for GesturesServ service

type GesturesServClient interface {
	CreateGesture(ctx context.Context, in *Gesture, opts ...grpc.CallOption) (*Gesture, error)
	GetGesture(ctx context.Context, in *Gesture, opts ...grpc.CallOption) (*Gesture, error)
	GetAllGesture(ctx context.Context, in *Gesture, opts ...grpc.CallOption) (*Gestures, error)
	DeleteGesture(ctx context.Context, in *Gesture, opts ...grpc.CallOption) (*Gesture, error)
}

type gesturesServClient struct {
	cc *grpc.ClientConn
}

func NewGesturesServClient(cc *grpc.ClientConn) GesturesServClient {
	return &gesturesServClient{cc}
}

func (c *gesturesServClient) CreateGesture(ctx context.Context, in *Gesture, opts ...grpc.CallOption) (*Gesture, error) {
	out := new(Gesture)
	err := grpc.Invoke(ctx, "/GesturesServ/CreateGesture", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gesturesServClient) GetGesture(ctx context.Context, in *Gesture, opts ...grpc.CallOption) (*Gesture, error) {
	out := new(Gesture)
	err := grpc.Invoke(ctx, "/GesturesServ/GetGesture", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gesturesServClient) GetAllGesture(ctx context.Context, in *Gesture, opts ...grpc.CallOption) (*Gestures, error) {
	out := new(Gestures)
	err := grpc.Invoke(ctx, "/GesturesServ/GetAllGesture", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gesturesServClient) DeleteGesture(ctx context.Context, in *Gesture, opts ...grpc.CallOption) (*Gesture, error) {
	out := new(Gesture)
	err := grpc.Invoke(ctx, "/GesturesServ/DeleteGesture", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for GesturesServ service

type GesturesServServer interface {
	CreateGesture(context.Context, *Gesture) (*Gesture, error)
	GetGesture(context.Context, *Gesture) (*Gesture, error)
	GetAllGesture(context.Context, *Gesture) (*Gestures, error)
	DeleteGesture(context.Context, *Gesture) (*Gesture, error)
}

func RegisterGesturesServServer(s *grpc.Server, srv GesturesServServer) {
	s.RegisterService(&_GesturesServ_serviceDesc, srv)
}

func _GesturesServ_CreateGesture_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Gesture)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GesturesServServer).CreateGesture(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/GesturesServ/CreateGesture",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GesturesServServer).CreateGesture(ctx, req.(*Gesture))
	}
	return interceptor(ctx, in, info, handler)
}

func _GesturesServ_GetGesture_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Gesture)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GesturesServServer).GetGesture(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/GesturesServ/GetGesture",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GesturesServServer).GetGesture(ctx, req.(*Gesture))
	}
	return interceptor(ctx, in, info, handler)
}

func _GesturesServ_GetAllGesture_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Gesture)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GesturesServServer).GetAllGesture(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/GesturesServ/GetAllGesture",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GesturesServServer).GetAllGesture(ctx, req.(*Gesture))
	}
	return interceptor(ctx, in, info, handler)
}

func _GesturesServ_DeleteGesture_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Gesture)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GesturesServServer).DeleteGesture(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/GesturesServ/DeleteGesture",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GesturesServServer).DeleteGesture(ctx, req.(*Gesture))
	}
	return interceptor(ctx, in, info, handler)
}

var _GesturesServ_serviceDesc = grpc.ServiceDesc{
	ServiceName: "GesturesServ",
	HandlerType: (*GesturesServServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateGesture",
			Handler:    _GesturesServ_CreateGesture_Handler,
		},
		{
			MethodName: "GetGesture",
			Handler:    _GesturesServ_GetGesture_Handler,
		},
		{
			MethodName: "GetAllGesture",
			Handler:    _GesturesServ_GetAllGesture_Handler,
		},
		{
			MethodName: "DeleteGesture",
			Handler:    _GesturesServ_DeleteGesture_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protobuf/move.proto",
}

// Client API for PipelinesServ service

type PipelinesServClient interface {
	CreatePipeline(ctx context.Context, in *Pipeline, opts ...grpc.CallOption) (*Pipeline, error)
	GetPipeline(ctx context.Context, in *Pipeline, opts ...grpc.CallOption) (*Pipeline, error)
	GetAllPipeline(ctx context.Context, in *Pipeline, opts ...grpc.CallOption) (*Pipelines, error)
	DeletePipeline(ctx context.Context, in *Pipeline, opts ...grpc.CallOption) (*Pipeline, error)
}

type pipelinesServClient struct {
	cc *grpc.ClientConn
}

func NewPipelinesServClient(cc *grpc.ClientConn) PipelinesServClient {
	return &pipelinesServClient{cc}
}

func (c *pipelinesServClient) CreatePipeline(ctx context.Context, in *Pipeline, opts ...grpc.CallOption) (*Pipeline, error) {
	out := new(Pipeline)
	err := grpc.Invoke(ctx, "/PipelinesServ/CreatePipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelinesServClient) GetPipeline(ctx context.Context, in *Pipeline, opts ...grpc.CallOption) (*Pipeline, error) {
	out := new(Pipeline)
	err := grpc.Invoke(ctx, "/PipelinesServ/GetPipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelinesServClient) GetAllPipeline(ctx context.Context, in *Pipeline, opts ...grpc.CallOption) (*Pipelines, error) {
	out := new(Pipelines)
	err := grpc.Invoke(ctx, "/PipelinesServ/GetAllPipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pipelinesServClient) DeletePipeline(ctx context.Context, in *Pipeline, opts ...grpc.CallOption) (*Pipeline, error) {
	out := new(Pipeline)
	err := grpc.Invoke(ctx, "/PipelinesServ/DeletePipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for PipelinesServ service

type PipelinesServServer interface {
	CreatePipeline(context.Context, *Pipeline) (*Pipeline, error)
	GetPipeline(context.Context, *Pipeline) (*Pipeline, error)
	GetAllPipeline(context.Context, *Pipeline) (*Pipelines, error)
	DeletePipeline(context.Context, *Pipeline) (*Pipeline, error)
}

func RegisterPipelinesServServer(s *grpc.Server, srv PipelinesServServer) {
	s.RegisterService(&_PipelinesServ_serviceDesc, srv)
}

func _PipelinesServ_CreatePipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pipeline)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinesServServer).CreatePipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PipelinesServ/CreatePipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinesServServer).CreatePipeline(ctx, req.(*Pipeline))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelinesServ_GetPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pipeline)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinesServServer).GetPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PipelinesServ/GetPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinesServServer).GetPipeline(ctx, req.(*Pipeline))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelinesServ_GetAllPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pipeline)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinesServServer).GetAllPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PipelinesServ/GetAllPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinesServServer).GetAllPipeline(ctx, req.(*Pipeline))
	}
	return interceptor(ctx, in, info, handler)
}

func _PipelinesServ_DeletePipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pipeline)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PipelinesServServer).DeletePipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/PipelinesServ/DeletePipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PipelinesServServer).DeletePipeline(ctx, req.(*Pipeline))
	}
	return interceptor(ctx, in, info, handler)
}

var _PipelinesServ_serviceDesc = grpc.ServiceDesc{
	ServiceName: "PipelinesServ",
	HandlerType: (*PipelinesServServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePipeline",
			Handler:    _PipelinesServ_CreatePipeline_Handler,
		},
		{
			MethodName: "GetPipeline",
			Handler:    _PipelinesServ_GetPipeline_Handler,
		},
		{
			MethodName: "GetAllPipeline",
			Handler:    _PipelinesServ_GetAllPipeline_Handler,
		},
		{
			MethodName: "DeletePipeline",
			Handler:    _PipelinesServ_DeletePipeline_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protobuf/move.proto",
}

// Client API for RequestGestureServ service

type RequestGestureServClient interface {
	PostGesture(ctx context.Context, in *GestureMessage, opts ...grpc.CallOption) (*GestureMessage, error)
}

type requestGestureServClient struct {
	cc *grpc.ClientConn
}

func NewRequestGestureServClient(cc *grpc.ClientConn) RequestGestureServClient {
	return &requestGestureServClient{cc}
}

func (c *requestGestureServClient) PostGesture(ctx context.Context, in *GestureMessage, opts ...grpc.CallOption) (*GestureMessage, error) {
	out := new(GestureMessage)
	err := grpc.Invoke(ctx, "/RequestGestureServ/PostGesture", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RequestGestureServ service

type RequestGestureServServer interface {
	PostGesture(context.Context, *GestureMessage) (*GestureMessage, error)
}

func RegisterRequestGestureServServer(s *grpc.Server, srv RequestGestureServServer) {
	s.RegisterService(&_RequestGestureServ_serviceDesc, srv)
}

func _RequestGestureServ_PostGesture_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GestureMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RequestGestureServServer).PostGesture(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/RequestGestureServ/PostGesture",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RequestGestureServServer).PostGesture(ctx, req.(*GestureMessage))
	}
	return interceptor(ctx, in, info, handler)
}

var _RequestGestureServ_serviceDesc = grpc.ServiceDesc{
	ServiceName: "RequestGestureServ",
	HandlerType: (*RequestGestureServServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PostGesture",
			Handler:    _RequestGestureServ_PostGesture_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protobuf/move.proto",
}

// Client API for HookServ service

type HookServClient interface {
	CreateHook(ctx context.Context, in *Hook, opts ...grpc.CallOption) (*Hook, error)
	GetHook(ctx context.Context, in *Hook, opts ...grpc.CallOption) (*Hook, error)
	PutHook(ctx context.Context, in *Hook, opts ...grpc.CallOption) (*Hook, error)
	GetAllHook(ctx context.Context, in *Hook, opts ...grpc.CallOption) (*Hooks, error)
}

type hookServClient struct {
	cc *grpc.ClientConn
}

func NewHookServClient(cc *grpc.ClientConn) HookServClient {
	return &hookServClient{cc}
}

func (c *hookServClient) CreateHook(ctx context.Context, in *Hook, opts ...grpc.CallOption) (*Hook, error) {
	out := new(Hook)
	err := grpc.Invoke(ctx, "/HookServ/CreateHook", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hookServClient) GetHook(ctx context.Context, in *Hook, opts ...grpc.CallOption) (*Hook, error) {
	out := new(Hook)
	err := grpc.Invoke(ctx, "/HookServ/GetHook", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hookServClient) PutHook(ctx context.Context, in *Hook, opts ...grpc.CallOption) (*Hook, error) {
	out := new(Hook)
	err := grpc.Invoke(ctx, "/HookServ/PutHook", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hookServClient) GetAllHook(ctx context.Context, in *Hook, opts ...grpc.CallOption) (*Hooks, error) {
	out := new(Hooks)
	err := grpc.Invoke(ctx, "/HookServ/GetAllHook", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for HookServ service

type HookServServer interface {
	CreateHook(context.Context, *Hook) (*Hook, error)
	GetHook(context.Context, *Hook) (*Hook, error)
	PutHook(context.Context, *Hook) (*Hook, error)
	GetAllHook(context.Context, *Hook) (*Hooks, error)
}

func RegisterHookServServer(s *grpc.Server, srv HookServServer) {
	s.RegisterService(&_HookServ_serviceDesc, srv)
}

func _HookServ_CreateHook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Hook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HookServServer).CreateHook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/HookServ/CreateHook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HookServServer).CreateHook(ctx, req.(*Hook))
	}
	return interceptor(ctx, in, info, handler)
}

func _HookServ_GetHook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Hook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HookServServer).GetHook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/HookServ/GetHook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HookServServer).GetHook(ctx, req.(*Hook))
	}
	return interceptor(ctx, in, info, handler)
}

func _HookServ_PutHook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Hook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HookServServer).PutHook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/HookServ/PutHook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HookServServer).PutHook(ctx, req.(*Hook))
	}
	return interceptor(ctx, in, info, handler)
}

func _HookServ_GetAllHook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Hook)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HookServServer).GetAllHook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/HookServ/GetAllHook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HookServServer).GetAllHook(ctx, req.(*Hook))
	}
	return interceptor(ctx, in, info, handler)
}

var _HookServ_serviceDesc = grpc.ServiceDesc{
	ServiceName: "HookServ",
	HandlerType: (*HookServServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateHook",
			Handler:    _HookServ_CreateHook_Handler,
		},
		{
			MethodName: "GetHook",
			Handler:    _HookServ_GetHook_Handler,
		},
		{
			MethodName: "PutHook",
			Handler:    _HookServ_PutHook_Handler,
		},
		{
			MethodName: "GetAllHook",
			Handler:    _HookServ_GetAllHook_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protobuf/move.proto",
}

func init() { proto.RegisterFile("protobuf/move.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 715 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x55, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0x96, 0x13, 0x3b, 0x4e, 0x26, 0x4d, 0x5a, 0xa6, 0x05, 0xac, 0x40, 0xa5, 0x68, 0x55, 0x89,
	0x28, 0xa0, 0x04, 0x02, 0x02, 0x14, 0x7e, 0xa4, 0x8a, 0x4a, 0xa1, 0x07, 0xa4, 0x2a, 0x70, 0xe2,
	0x82, 0x5c, 0xbc, 0xa4, 0x56, 0x13, 0x6f, 0xf0, 0xae, 0x2b, 0x24, 0xe0, 0xc2, 0x81, 0x17, 0xe0,
	0xc4, 0xe3, 0xf0, 0x0c, 0xdc, 0x38, 0xf3, 0x0a, 0xdc, 0xd1, 0xfe, 0x39, 0x4e, 0x52, 0x15, 0x4e,
	0x9e, 0x99, 0x9d, 0xef, 0x9b, 0x99, 0x6f, 0x67, 0x13, 0xd8, 0x9e, 0xa7, 0x4c, 0xb0, 0xe3, 0xec,
	0x5d, 0x7f, 0xc6, 0xce, 0x68, 0x4f, 0x79, 0xad, 0xeb, 0x13, 0xc6, 0x26, 0x53, 0xda, 0x0f, 0xe7,
	0x71, 0x3f, 0x4c, 0x12, 0x26, 0x42, 0x11, 0xb3, 0x84, 0xeb, 0x53, 0xf2, 0xcb, 0x81, 0xea, 0x51,
	0x3c, 0xa7, 0xd3, 0x38, 0xa1, 0xd8, 0x84, 0x52, 0x1c, 0x05, 0x4e, 0xdb, 0xe9, 0xd4, 0xc6, 0xa5,
	0x38, 0xc2, 0xab, 0xe0, 0x67, 0x9c, 0xa6, 0x6f, 0xe2, 0x28, 0x28, 0xa9, 0x60, 0x45, 0xba, 0x87,
	0x11, 0xb6, 0xa1, 0x1e, 0x51, 0xfe, 0x36, 0x8d, 0xe7, 0x92, 0x2b, 0x28, 0xab, 0xc3, 0x62, 0x08,
	0x77, 0xc1, 0x4d, 0xe8, 0x07, 0x11, 0xb8, 0xed, 0x72, 0xa7, 0x3e, 0xa8, 0xf5, 0x6c, 0x8d, 0xb1,
	0x0a, 0xe3, 0x2e, 0xc0, 0x84, 0x72, 0x91, 0xa5, 0x54, 0x92, 0x7b, 0x0a, 0x5f, 0x33, 0x91, 0xc3,
	0x08, 0x03, 0xf0, 0x45, 0x3c, 0xa3, 0x2c, 0x13, 0x41, 0xa5, 0xed, 0x74, 0xca, 0x63, 0xeb, 0x22,
	0x82, 0x9b, 0x84, 0x33, 0x1a, 0xf8, 0x0a, 0xa2, 0x6c, 0xd9, 0xe6, 0x09, 0x63, 0xa7, 0x92, 0xa9,
	0xaa, 0xdb, 0x94, 0xee, 0x61, 0x44, 0x3e, 0x81, 0x3f, 0xd2, 0x9c, 0x6b, 0xa3, 0xad, 0x4c, 0x50,
	0x5a, 0x9f, 0x00, 0xc1, 0x9d, 0x51, 0x11, 0x9a, 0xe1, 0x94, 0x9d, 0x57, 0x77, 0x97, 0xab, 0x5b,
	0x91, 0xbc, 0xa2, 0x48, 0xe4, 0x36, 0x54, 0x4d, 0x75, 0x8e, 0x7b, 0x50, 0x35, 0xd3, 0xf1, 0xc0,
	0x51, 0x92, 0x54, 0x7b, 0xe6, 0x70, 0x9c, 0x9f, 0x90, 0x7b, 0x50, 0xb3, 0x3a, 0x71, 0xbc, 0x01,
	0xb5, 0xb9, 0x75, 0x0c, 0xa6, 0x20, 0xe3, 0xe2, 0x8c, 0xec, 0x81, 0xf7, 0x9c, 0xb1, 0x53, 0x8e,
	0xd7, 0xc0, 0x93, 0x83, 0xdb, 0x6c, 0xaf, 0x27, 0xc3, 0x63, 0x1d, 0x23, 0x4f, 0xa0, 0x69, 0x0a,
	0xbe, 0xa0, 0x9c, 0x87, 0x93, 0xa5, 0xc6, 0x9d, 0xa5, 0xdb, 0xb5, 0x93, 0x97, 0x16, 0x93, 0x93,
	0xef, 0x0e, 0xb8, 0x92, 0x6e, 0x4d, 0xc8, 0x00, 0xfc, 0x99, 0x26, 0x34, 0xf9, 0xd6, 0xcd, 0xc5,
	0x2a, 0x17, 0xc4, 0x5a, 0x91, 0xdd, 0x5d, 0x97, 0x3d, 0x00, 0x3f, 0x8c, 0xa2, 0x94, 0x72, 0x6e,
	0xe4, 0xb4, 0x6e, 0xb1, 0xdf, 0xca, 0x92, 0xd0, 0xbb, 0xe0, 0xbd, 0x62, 0xa7, 0x34, 0xc1, 0x1d,
	0xf0, 0x84, 0x34, 0x4c, 0x7b, 0xda, 0x19, 0xdc, 0x01, 0x6f, 0x3f, 0x13, 0x27, 0x1c, 0x3b, 0xe0,
	0x4a, 0x03, 0x2b, 0x3d, 0x95, 0xde, 0x32, 0x5f, 0xb2, 0xf5, 0xe5, 0xe7, 0xef, 0x6f, 0x25, 0x20,
	0x5e, 0x3f, 0xcc, 0xc4, 0xc9, 0xd0, 0xe9, 0x0e, 0xfe, 0x38, 0xb0, 0x61, 0xef, 0xee, 0x25, 0x4d,
	0xcf, 0xf0, 0x21, 0x34, 0x9e, 0xa5, 0x34, 0x14, 0xd4, 0xee, 0x53, 0x7e, 0x7d, 0xad, 0xdc, 0x22,
	0xdb, 0x8a, 0xa7, 0x41, 0xaa, 0x7d, 0x73, 0xa3, 0x43, 0xa7, 0x8b, 0x0f, 0x00, 0x46, 0x54, 0x5c,
	0x04, 0xbb, 0xac, 0x60, 0x9b, 0xd8, 0xb0, 0xb0, 0xfe, 0xc7, 0x38, 0xfa, 0x8c, 0xf7, 0xa1, 0x31,
	0xa2, 0x62, 0x7f, 0x3a, 0x5d, 0xc7, 0xd6, 0xac, 0xc5, 0x6d, 0xef, 0x98, 0xd7, 0xc4, 0x21, 0x34,
	0x0e, 0xe8, 0x94, 0x5e, 0xdc, 0xaa, 0xa9, 0xd9, 0x5d, 0xae, 0x39, 0xf8, 0x5a, 0x82, 0x46, 0xbe,
	0x81, 0x6a, 0xf0, 0xc7, 0xd0, 0xd4, 0x83, 0xe7, 0x3f, 0x12, 0x8b, 0x25, 0x6c, 0x2d, 0x4c, 0xb2,
	0xa3, 0x08, 0x9b, 0xa4, 0xd6, 0xb7, 0x8b, 0x29, 0x87, 0x7f, 0x04, 0xf5, 0x11, 0x15, 0xff, 0x80,
	0x5e, 0x51, 0xd0, 0x2d, 0x6c, 0xe6, 0x50, 0x2d, 0xc0, 0x50, 0x6e, 0xac, 0x14, 0xe0, 0x3c, 0x3c,
	0xe4, 0x26, 0x27, 0x97, 0x14, 0x41, 0x1d, 0x17, 0xb5, 0xf1, 0x29, 0x34, 0xb5, 0x08, 0xff, 0x57,
	0xbb, 0xbb, 0x52, 0x7b, 0xf0, 0x1a, 0x70, 0x4c, 0xdf, 0x67, 0x94, 0xdb, 0x9b, 0x53, 0x62, 0x1c,
	0x40, 0xfd, 0x88, 0xe5, 0x21, 0xdc, 0xec, 0x2d, 0xbf, 0xa8, 0xd6, 0x6a, 0xa0, 0xb0, 0x11, 0xa9,
	0x66, 0x93, 0xcb, 0xf5, 0xc3, 0x81, 0xaa, 0x7c, 0x4a, 0x8a, 0xf2, 0x16, 0x80, 0xd6, 0x57, 0x3d,
	0x2e, 0xfd, 0x64, 0x5b, 0xfa, 0x53, 0xd8, 0x4b, 0xf9, 0x84, 0xa5, 0x9e, 0x37, 0xe5, 0x0f, 0x9a,
	0x38, 0x27, 0x15, 0x55, 0xea, 0x06, 0x82, 0x4a, 0xd5, 0xfa, 0xf5, 0xc0, 0x3f, 0xca, 0xce, 0x4b,
	0x36, 0x97, 0xdf, 0x2a, 0x24, 0x4b, 0xf2, 0xae, 0xda, 0xd4, 0xfd, 0xe9, 0xb4, 0x08, 0xa9, 0xa8,
	0x0f, 0x27, 0x0d, 0x85, 0xf1, 0x51, 0xf7, 0x72, 0x5c, 0x51, 0xff, 0x1e, 0x77, 0xff, 0x06, 0x00,
	0x00, 0xff, 0xff, 0x6b, 0xc3, 0x0d, 0x80, 0x72, 0x06, 0x00, 0x00,
}
